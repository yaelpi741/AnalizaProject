def evaluate_polynomial(coeffs, x):
    """
    Evaluates a polynomial at a given value x.

    Parameters:
    -----------
    coeffs : list of float
        Coefficients of the polynomial, ordered from highest degree to constant term.
    x : float
        The point at which to evaluate the polynomial.

    Returns:
    --------
    float
        The value of the polynomial at x.

    Raises:
    -------
    ValueError:
        If the coefficient list is empty.
    TypeError:
        If any coefficient is not a number.
    """
    if not coeffs:
        raise ValueError("Coefficient list is empty – cannot evaluate polynomial.")
    result = 0
    degree = len(coeffs) - 1
    for i, coef in enumerate(coeffs):
        if not isinstance(coef, (int, float)):
            raise TypeError(f"Invalid coefficient: {coef} is not a number.")
        result += coef * (x ** (degree - i))
    return result


def trapezoidal_rule(left, right, coeffs, step=0.1):
    """
    Approximates the definite integral of a polynomial using the Trapezoidal Rule.

    Parameters:
    -----------
    left : float
        The left boundary of the integral.
    right : float
        The right boundary of the integral.
    coeffs : list of float
        Coefficients of the polynomial, ordered from highest degree to constant.
    step : float, optional (default=0.1)
        The width of each subinterval (must be positive).

    Returns:
    --------
    float
        Approximate value of the definite integral over [left, right].

    Raises:
    -------
    ValueError:
        If step size is non-positive or no subintervals can be created.
    """
    if step <= 0:
        raise ValueError("Step size must be positive.")
    if left == right:
        return 0.0  # Zero area under the curve when interval length is zero
    if left > right:
        # Flip boundaries and negate result
        return -trapezoidal_rule(right, left, coeffs, step)

    n = int((right - left) / step)
    if n == 0:
        raise ValueError("Interval too small relative to step size – no subintervals created.")

    total_area = 0
    for i in range(n):
        a = left + i * step
        b = a + step
        fa = evaluate_polynomial(coeffs, a)
        fb = evaluate_polynomial(coeffs, b)
        area = (step / 2) * (fa + fb)
        total_area += area

    return total_area


def run_tests():
    """
    Runs a set of test cases on the trapezoidal_rule function
    to validate correctness and edge case handling.
    """
    test_cases = [
        {"coeffs": [1, 2, 1], "a": 0, "b": 1},        # Normal case: x^2 + 2x + 1 from 0 to 1
        {"coeffs": [5], "a": 0, "b": 3},              # Constant function
        {"coeffs": [1, 0, 0, 0], "a": 0, "b": 10},     # x^3
        {"coeffs": [], "a": 0, "b": 1},               # Empty coefficients
        {"coeffs": [1, 'a'], "a": 0, "b": 1},         # Invalid coefficient
        {"coeffs": [1], "a": 2, "b": 2},              # Zero-length interval
        {"coeffs": [1], "a": 3, "b": 1},              # Reversed interval
        {"coeffs": [1], "a": 0, "b": 0.01, "step": 0.02},  # Step too large
    ]

    for idx, test in enumerate(test_cases):
        try:
            print(f"\nTest {idx + 1}: {test}")
            result = trapezoidal_rule(
                test["a"], test["b"], test["coeffs"], test.get("step", 0.1)
            )
            print("Result:", result)
        except Exception as e:
            print("Error:", e)

# Run all tests
run_tests()
